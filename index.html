<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js 分子實驗室 (增量控制版)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: sans-serif;
            color: #ffffff;
            user-select: none; /* 禁止選取文字 */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI 面板 */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 400px;
            padding: 10px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 30px;
            z-index: 10;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .input-group {
            display: flex;
            width: 100%;
            gap: 8px;
        }

        input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 10px;
            color: white;
            outline: none;
            font-size: 16px;
            text-align: center;
        }
        
        button {
            background: #2196F3;
            border: none;
            padding: 8px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
        }

        /* 強制隱藏攝影機元素的終極方案 
           設定 visibility: hidden 且移出畫面，確保不佔位也不顯示
        */
        .input_video, #input_video, .mediapipe-video {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            top: -10000px !important;
            left: -10000px !important;
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none !important;
            z-index: -999 !important;
        }
        
        /* 狀態指示器 */
        #status-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 16px;
            background: rgba(0,0,0,0.6);
            border-radius: 20px;
            font-size: 13px;
            color: #ccc;
            z-index: 9;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0; /* 預設隱藏 */
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #status-indicator.visible {
            opacity: 1;
        }
        .icon { font-size: 14px; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="input-group">
            <input type="text" id="molecule-input" placeholder="輸入分子 (如 Aspirin)" value="Caffeine">
            <button onclick="fetchMolecule()">載入</button>
        </div>
    </div>

    <div id="status-indicator">
        <span class="icon">✊</span> <span>重置位置中 (暫停旋轉)</span>
    </div>

    <div id="canvas-container"></div>
    
    <video id="input_video" class="input_video" playsinline></video>

<script>
    // --- 變數 ---
    let scene, camera, renderer, moleculeGroup;
    
    // 控制變數
    let currentRotationX = 0;
    let currentRotationY = 0;
    let currentScale = 1;
    
    let lastHandX = null;
    let lastHandY = null;
    let lastPinchDist = null;

    // CPK 配色表
    const CPK_COLORS = {
        'H': 0xFFFFFF, 'C': 0x909090, 'N': 0x3050F8, 'O': 0xFF0D0D,
        'F': 0x90E050, 'CL': 0x1FF01F, 'BR': 0xA62929, 'I': 0x940094,
        'S': 0xFFFF30, 'P': 0xFF8000
    };

    // --- Three.js 初始化 ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a); // 極深灰背景

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 22;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 效能優化
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x707070, 2);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 10, 15);
        scene.add(dirLight);
        const backLight = new THREE.DirectionalLight(0x0055ff, 0.5); // 藍色邊緣光
        backLight.position.set(-10, 0, -10);
        scene.add(backLight);

        moleculeGroup = new THREE.Group();
        scene.add(moleculeGroup);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- 分子生成邏輯 ---
    function createAtom(element, x, y, z) {
        const color = CPK_COLORS[element.toUpperCase()] || 0xFF00FF;
        const radius = element.toUpperCase() === 'H' ? 0.35 : 0.6; 
        const geometry = new THREE.SphereGeometry(radius, 24, 24); // 降低面數優化手機效能
        const material = new THREE.MeshPhongMaterial({ color: color, shininess: 80 });
        const atom = new THREE.Mesh(geometry, material);
        atom.position.set(x, y, z);
        return atom;
    }

    function createBond(p1, p2) {
        const direction = new THREE.Vector3().subVectors(p2, p1);
        const geometry = new THREE.CylinderGeometry(0.15, 0.15, direction.length(), 8);
        const material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const bond = new THREE.Mesh(geometry, material);
        bond.position.copy(p1).add(p2).multiplyScalar(0.5);
        bond.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
        return bond;
    }

    async function fetchMolecule() {
        const name = document.getElementById('molecule-input').value;
        const btn = document.querySelector('button');
        btn.innerText = "讀取中...";
        try {
            const url = `https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${name}/JSON?record_type=3d`;
            const response = await fetch(url);
            if (!response.ok) throw new Error("API Error");
            const data = await response.json();
            const compound = data.PC_Compounds[0];
            
            // 清除舊分子
            while(moleculeGroup.children.length > 0) moleculeGroup.remove(moleculeGroup.children[0]);

            const coords = compound.coords[0].conformers[0];
            const atoms = compound.atoms;
            const atomMeshes = [];
            let cx = 0, cy = 0, cz = 0;

            for (let i = 0; i < atoms.aid.length; i++) {
                const element = getElementSymbol(atoms.element[i]);
                const x = coords.x[i], y = coords.y[i], z = coords.z[i];
                const atom = createAtom(element, x, y, z);
                moleculeGroup.add(atom);
                atomMeshes.push({mesh: atom});
                cx += x; cy += y; cz += z;
            }
            
            // 置中計算
            cx /= atoms.aid.length; cy /= atoms.aid.length; cz /= atoms.aid.length;
            moleculeGroup.position.set(-cx, -cy, -cz);

            if (compound.bonds) {
                const aid1 = compound.bonds.aid1;
                const aid2 = compound.bonds.aid2;
                for (let i = 0; i < aid1.length; i++) {
                    const idx1 = aid1[i] - 1;
                    const idx2 = aid2[i] - 1;
                    if(atomMeshes[idx1] && atomMeshes[idx2]) {
                        moleculeGroup.add(createBond(atomMeshes[idx1].mesh.position, atomMeshes[idx2].mesh.position));
                    }
                }
            }
            
            // 重置狀態
            currentScale = 1;
            moleculeGroup.scale.set(1, 1, 1);
            moleculeGroup.rotation.set(0,0,0);
            currentRotationX = 0;
            currentRotationY = 0;
            
        } catch (e) { alert("找不到該分子，請檢查拼字。"); }
        btn.innerText = "載入";
    }

    function getElementSymbol(n) {
        const t = {1:'H', 6:'C', 7:'N', 8:'O', 9:'F', 15:'P', 16:'S', 17:'CL', 35:'BR', 53:'I'};
        return t[n] || 'C';
    }

    // --- MediaPipe 邏輯 ---
    const videoElement = document.getElementById('input_video');
    const statusIndicator = document.getElementById('status-indicator');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 關鍵點
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const handCenter = landmarks[9]; // 中指根部，作為手的位置

            // 1. 判斷握拳 (Fist Detection)
            // 簡單算法：指尖與手腕距離過近 = 握拳
            const palmLen = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));
            const isFist = palmLen < 0.15; // 閾值 (視情況微調)

            if (isFist) {
                // --- 狀態：握拳 (暫停/重置) ---
                statusIndicator.classList.add('visible');
                
                // 握拳時，我們只更新「上一次的位置」，但不更新旋轉角度
                // 這樣當下次張開手時，移動量會從新的位置開始算，不會跳動
                lastHandX = handCenter.x;
                lastHandY = handCenter.y;
                lastPinchDist = null; // 重置縮放基準

            } else {
                // --- 狀態：張手 (操作中) ---
                statusIndicator.classList.remove('visible');

                // A. 處理旋轉 (使用增量/Delta)
                if (lastHandX !== null && lastHandY !== null) {
                    // 計算手移動了多少 (Delta)
                    const deltaX = handCenter.x - lastHandX;
                    const deltaY = handCenter.y - lastHandY;
                    
                    // 靈敏度係數 (可以調大一點讓轉動更快)
                    const rotSensitivity = 4.0;

                    // 累加角度 (注意：X軸移動控制Y軸旋轉，反之亦然)
                    currentRotationY += deltaX * rotSensitivity;
                    currentRotationX += deltaY * rotSensitivity;
                }

                // 更新「上一次位置」為「現在位置」
                lastHandX = handCenter.x;
                lastHandY = handCenter.y;


                // B. 處理縮放 (使用增量/Delta)
                // 計算拇指與食指距離
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
                
                if (lastPinchDist !== null) {
                    const deltaPinch = pinchDist - lastPinchDist;
                    const scaleSensitivity = 3.5;
                    
                    currentScale += deltaPinch * scaleSensitivity;
                    currentScale = Math.max(0.1, Math.min(currentScale, 8.0)); // 限制大小
                }
                
                lastPinchDist = pinchDist;
            }

        } else {
            // 手離開畫面，重置追蹤數據
            lastHandX = null;
            lastHandY = null;
            lastPinchDist = null;
            statusIndicator.classList.remove('visible');
        }
    }

    // MediaPipe 設定
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    // --- 渲染迴圈 ---
    function animate() {
        requestAnimationFrame(animate);

        if (moleculeGroup) {
            // 平滑插值 (Lerp) 讓畫面更順暢
            // 旋轉
            moleculeGroup.rotation.y += (currentRotationY - moleculeGroup.rotation.y) * 0.1;
            moleculeGroup.rotation.x += (currentRotationX - moleculeGroup.rotation.x) * 0.1;
            
            // 縮放
            const s = moleculeGroup.scale.x;
            const newS = s + (currentScale - s) * 0.15;
            moleculeGroup.scale.set(newS, newS, newS);
        }
        renderer.render(scene, camera);
    }

    initThree();
    fetchMolecule();
    animate();
</script>
</body>
</html>
