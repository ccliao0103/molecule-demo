<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js åˆ†å­å¯¦é©—å®¤</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: sans-serif;
            color: #ffffff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI é¢æ¿ï¼šç§»é™¤ç‹€æ…‹æ–‡å­—èˆ‡é è¦½åœ–ï¼Œä¿ç•™è¼¸å…¥æ¡† */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%); /* ç½®ä¸­ */
            width: 80%;
            max-width: 400px;
            padding: 15px;
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(5px);
            border-radius: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .input-group {
            display: flex;
            width: 100%;
            gap: 8px;
        }

        input {
            flex: 1;
            background: rgba(255,255,255,0.15);
            border: none;
            padding: 12px;
            border-radius: 10px;
            color: white;
            outline: none;
            font-size: 16px;
        }

        button {
            background: #4db8ff;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            color: #121212;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
        }

        /* éš±è—æ”å½±æ©Ÿç›¸é—œå…ƒç´  */
        #input_video, #webcam-preview, .status {
            display: none !important;
        }
        
        /* é–å®šç‹€æ…‹æŒ‡ç¤ºå™¨ (é¸ç”¨ï¼šè®“ä½¿ç”¨è€…çŸ¥é“ç¾åœ¨æ˜¯é–å®šé‚„æ˜¯æ“ä½œä¸­) */
        #lock-indicator {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 15px;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            font-size: 12px;
            color: #aaa;
            z-index: 9;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0;
        }
        #lock-indicator.visible {
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="input-group">
            <input type="text" id="molecule-input" placeholder="Enter Molecule (e.g. Water)" value="Caffeine">
            <button onclick="fetchMolecule()">Go</button>
        </div>
    </div>

    <div id="lock-indicator">ğŸ”’ é–å®šä¸­ (æ¡æ‹³é‡ç½®æ‰‹æŒ‡)</div>

    <div id="canvas-container"></div>
    
    <video id="input_video" playsinline></video>

<script>
    // --- è®Šæ•¸ ---
    let scene, camera, renderer, moleculeGroup;
    let targetRotationX = 0;
    let targetRotationY = 0;
    
    // ç¸®æ”¾æ§åˆ¶è®Šæ•¸
    let currentScale = 1;      // ç›®å‰çš„å¯¦éš›å¤§å°
    let lastFingerDist = null; // ä¸Šä¸€å¹€çš„æ‰‹æŒ‡è·é›¢
    let isLocked = false;      // æ˜¯å¦è™•æ–¼æ¡æ‹³é–å®šç‹€æ…‹

    const CPK_COLORS = {
        'H': 0xFFFFFF, 'C': 0x909090, 'N': 0x3050F8, 'O': 0xFF0D0D,
        'F': 0x90E050, 'CL': 0x1FF01F, 'BR': 0xA62929, 'I': 0x940094,
        'S': 0xFFFF30, 'P': 0xFF8000
    };

    // --- Three.js åˆå§‹åŒ– ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // ç´”é»‘èƒŒæ™¯çœ‹èµ·ä¾†æ›´åƒå…¨æ¯æŠ•å½±

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x606060, 2);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(10, 10, 10);
        scene.add(dirLight);

        moleculeGroup = new THREE.Group();
        scene.add(moleculeGroup);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- åˆ†å­ç”Ÿæˆ (èˆ‡ä¹‹å‰ç›¸åŒ) ---
    function createAtom(element, x, y, z) {
        const color = CPK_COLORS[element.toUpperCase()] || 0xFF00FF;
        const radius = element.toUpperCase() === 'H' ? 0.3 : 0.5;
        const geometry = new THREE.SphereGeometry(radius, 32, 32);
        const material = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
        const atom = new THREE.Mesh(geometry, material);
        atom.position.set(x, y, z);
        return atom;
    }

    function createBond(p1, p2) {
        const direction = new THREE.Vector3().subVectors(p2, p1);
        const geometry = new THREE.CylinderGeometry(0.1, 0.1, direction.length(), 12);
        const material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const bond = new THREE.Mesh(geometry, material);
        bond.position.copy(p1).add(p2).multiplyScalar(0.5);
        bond.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
        return bond;
    }

    async function fetchMolecule() {
        const name = document.getElementById('molecule-input').value;
        const btn = document.querySelector('button');
        btn.innerText = "...";
        try {
            const url = `https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${name}/JSON?record_type=3d`;
            const response = await fetch(url);
            if (!response.ok) throw new Error("Error");
            const data = await response.json();
            const compound = data.PC_Compounds[0];
            
            while(moleculeGroup.children.length > 0) moleculeGroup.remove(moleculeGroup.children[0]);

            const coords = compound.coords[0].conformers[0];
            const atoms = compound.atoms;
            const atomMeshes = [];
            let cx = 0, cy = 0, cz = 0;

            for (let i = 0; i < atoms.aid.length; i++) {
                const element = getElementSymbol(atoms.element[i]);
                const x = coords.x[i], y = coords.y[i], z = coords.z[i];
                const atom = createAtom(element, x, y, z);
                moleculeGroup.add(atom);
                atomMeshes.push({mesh: atom});
                cx += x; cy += y; cz += z;
            }
            
            cx /= atoms.aid.length; cy /= atoms.aid.length; cz /= atoms.aid.length;
            moleculeGroup.position.set(-cx, -cy, -cz);

            if (compound.bonds) {
                const aid1 = compound.bonds.aid1;
                const aid2 = compound.bonds.aid2;
                for (let i = 0; i < aid1.length; i++) {
                    const idx1 = aid1[i] - 1;
                    const idx2 = aid2[i] - 1;
                    if(atomMeshes[idx1] && atomMeshes[idx2]) {
                        moleculeGroup.add(createBond(atomMeshes[idx1].mesh.position, atomMeshes[idx2].mesh.position));
                    }
                }
            }
            
            // é‡ç½®
            currentScale = 1;
            lastFingerDist = null;
            moleculeGroup.scale.set(1, 1, 1);
            moleculeGroup.rotation.set(0,0,0);
            
        } catch (e) { alert("æ‰¾ä¸åˆ°åˆ†å­"); }
        btn.innerText = "Go";
    }

    function getElementSymbol(n) {
        const t = {1:'H', 6:'C', 7:'N', 8:'O', 9:'F', 15:'P', 16:'S', 17:'CL', 35:'BR', 53:'I'};
        return t[n] || 'C';
    }

    // --- MediaPipe é‚è¼¯ ---
    const videoElement = document.getElementById('input_video');
    const lockIndicator = document.getElementById('lock-indicator');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. åˆ¤æ–·æ˜¯å¦æ¡æ‹³ (æª¢æŸ¥ä¸­æŒ‡æŒ‡å°–èˆ‡æ‰‹è…•çš„è·é›¢)
            // 9: Middle Finger MCP (æ ¹éƒ¨), 12: Middle Finger Tip (æŒ‡å°–), 0: Wrist
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const middleBase = landmarks[9];
            
            // ç°¡å–®åˆ¤æ–·ï¼šæŒ‡å°–éå¸¸é è¿‘æ ¹éƒ¨/æ‰‹è…•
            const palmOpenDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));
            
            // é–¾å€¼éœ€æ¸¬è©¦ï¼Œé€šå¸¸å¼µé–‹æ™‚è·é›¢ > 0.3ï¼Œæ¡æ‹³æ™‚ < 0.2 (æ­£è¦åŒ–åº§æ¨™)
            // é€™è£¡è¨­å®š 0.15 ä½œç‚ºåˆ†ç•Œ (è¦–é¡é ­è·é›¢è€Œå®šï¼Œå¯å¾®èª¿)
            const isFist = palmOpenDist < 0.2; 

            if (isFist) {
                isLocked = true;
                lockIndicator.classList.add('visible');
                lastFingerDist = null; // é‡ç½®è·é›¢è¨˜æ†¶ï¼Œæº–å‚™ä¸‹ä¸€æ¬¡é‡æ–°æ¥åˆ
            } else {
                isLocked = false;
                lockIndicator.classList.remove('visible');
                
                // --- 2. æ—‹è½‰é‚è¼¯ (ä¿æŒæ‰‹è…•ä½ç½®æ§åˆ¶) ---
                const handX = landmarks[9].x; 
                const handY = landmarks[9].y;
                targetRotationY = (handX - 0.5) * 6; 
                targetRotationX = (handY - 0.5) * 6;

                // --- 3. ç¸®æ”¾é‚è¼¯ (ç›¸å°å¢é‡) ---
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const dist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                if (lastFingerDist !== null) {
                    // è¨ˆç®—è®ŠåŒ–é‡
                    const delta = dist - lastFingerDist;
                    // éˆæ•åº¦
                    const sensitivity = 3.0; 
                    
                    // ç´¯åŠ åˆ° currentScale
                    currentScale += delta * sensitivity;
                    
                    // é™åˆ¶ç¯„åœ (0.1å€ ~ 10å€)
                    currentScale = Math.max(0.1, Math.min(currentScale, 10.0));
                }
                
                // æ›´æ–°ä¸Šä¸€å¹€è·é›¢
                lastFingerDist = dist;
            }

        } else {
            // æ‰‹é›¢é–‹ç•«é¢æ™‚ï¼Œè¦–ç‚ºé–å®šï¼Œé‡ç½®è·é›¢
            lastFingerDist = null;
            lockIndicator.classList.remove('visible');
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6, // æé«˜ä¸€é»ä»¥é˜²èª¤åˆ¤
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    // --- æ¸²æŸ“è¿´åœˆ ---
    function animate() {
        requestAnimationFrame(animate);

        if (moleculeGroup) {
            // å¹³æ»‘æ—‹è½‰
            moleculeGroup.rotation.y += (targetRotationY - moleculeGroup.rotation.y) * 0.1;
            moleculeGroup.rotation.x += (targetRotationX - moleculeGroup.rotation.x) * 0.1;
            
            // å¹³æ»‘ç¸®æ”¾
            const s = moleculeGroup.scale.x;
            const newS = s + (currentScale - s) * 0.15;
            moleculeGroup.scale.set(newS, newS, newS);
        }
        renderer.render(scene, camera);
    }

    initThree();
    fetchMolecule();
    animate();
</script>
</body>
</html>
